<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Языки программирования: C</title>
		<link rel="stylesheet" href="index.css" />
	</head>
	<body>
		<nav class="header" id = "header">
			<a href="index.html"><img src="images/home.png" class = "home_icon" alt="Главная" /></a>
			<ul>
				<li><a class="header_link" href="java.html">Java</a></li>
				<li><a class="header_link" href="c.html">C</a></li>
				<li><a class="header_link" href="pascalabc.html">PascalABC</a></li>
				<li><a class="header_link" href="fs.html">F#</a></li>
			</ul>

			<div class="header_submenu" id="java_submenu">
				<ul>
					<li><a class="header_submenu_link" href="java.html#key_elements">Ключевые элементы</a></li>
					<li><a class="header_submenu_link" href="java.html#syntax">Элементы синтаксиса</a></li>
					<li><a class="header_submenu_link" href="java.html#example">Пример кода</a></li>
				</ul>
			</div>
			<div class="header_submenu" id="c_submenu">
				<ul>
					<li><a href="c.html#key_features" class="header_submenu_link">Важные особенности</a></li>
					<li><a href="c.html#syntax" class="header_submenu_link">Описание синтаксиса</a></li>
				</ul>
			</div>
			<div class="header_submenu" id="pascalabc_submenu">
				<ul>
					<li><a href="pascalabc.html#features" class="header_submenu_link">Особенности языка</a></li>
				</ul>
			</div>
			<div class="header_submenu" id="fs_submenu">
				<ul>
					<li><a href="fs.html#features" class="header_submenu_link">Особенности</a></li>
					<li><a href="fs.html#compile" class="header_submenu_link">Компилятор и интерпретатор</a></li>
					<li><a href="fs.html#examples" class="header_submenu_link">Примеры</a></li>
				</ul>
			</div>
		</nav>
		<div class="wrapper">
			<div class="wrapper_text_container">
<h1>Си</h1>

<img class='img_right' src='images/Си.jpg'>
<p>Си (англ. C) — стандартизированный процедурный язык программирования, разработанный в начале 1970-х годов сотрудниками Bell Labs Кеном Томпсоном и Денисом Ритчи как развитие языка Би. Си был создан для использования в операционной системе UNIX. С тех пор он был портирован на многие другие операционные системы и стал одним из самых используемых языков программирования. Си ценят за его эффективность. Он является самым популярным языком для создания системного программного обеспечения. Его также часто используют для создания прикладных программ. Несмотря на то, что Си не разрабатывался для новичков, он активно используется для обучения программированию. В дальнейшем синтаксис языка Си стал основой для многих других языков (см.: Си-подобный синтаксис).</p>
<a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%BE%D0%BC%D0%BF%D1%81%D0%BE%D0%BD,_%D0%9A%D0%B5%D0%BD"><img class = 'img_right' src='images/KenTomp.jpg' alt='Ken Tompson'></a>
<p>Для языка Си характерны лаконичность, современный набор конструкций управления потоком выполнения, структур данных и обширный набор операций.</p>
<p>Язык программирования Си отличается минимализмом. Авторы языка хотели, чтобы программы на нём легко компилировались с помощью однопроходного компилятора, чтобы каждой элементарной составляющей программы после компиляции соответствовало весьма небольшое число машинных команд, а использование базовых элементов языка не задействовало библиотеку времени выполнения. Однопроходный компилятор компилирует программу, не возвращаясь назад, к уже обработанному тексту. Поэтому использованию функции должно предшествовать её объявление. Код на Си можно легко писать на низком уровне абстракции, почти как на ассемблере. Иногда Си называют «универсальным ассемблером» или «ассемблером высокого уровня», что отражает различие языков ассемблера для разных платформ и единство стандарта Си, код которого может быть скомпилирован без изменений практически на любой модели компьютера. Си часто называют языком среднего уровня или даже низкого уровня, учитывая то, как близко он работает к реальным устройствам.</p>
<a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B8%D1%82%D1%87%D0%B8,_%D0%94%D0%B5%D0%BD%D0%BD%D0%B8%D1%81"><img class='img_left' src='images/DenRitchie.jpg' alt='Den Ritchie'></a>
<p>Компиляторы Си разрабатываются сравнительно легко благодаря относительно низкому уровню языка и скромному набору элементов. Поэтому данный язык доступен на самых различных платформах (возможно, круг этих платформ шире, чем у любого другого существующего языка). К тому же, несмотря на свою низкоуровневую природу, язык позволяет создавать переносимые программы и поддерживает в этом программиста. Программы, соответствующие стандарту языка, могут компилироваться на самых различных компьютерах.</p>
<p>Си (как и ОС UNIX, с которой он долгое время был связан) создавался программистами и для программистов, круг которых был бы ненамного шире круга разработчиков языка. Несмотря на это, область использования языка значительно шире задач системного программирования.</p>
<a name="key_features"></a>
<p>Си создавался с одной важной целью: сделать более простым написание больших программ с минимумом ошибок по правилам процедурного программирования, не добавляя на итоговый код программ лишних накладных расходов для компилятора, как это всегда делают языки очень высокого уровня, такие как Бейсик.</p>
<h2>С этой стороны Си имеет следующие важные особенности:</h2><ul>
	<li>языковую базу, из которой вынесены в библиотеки многие существенные возможности, вроде математических функций или функций управления файлами;</li>
	<li>ориентацию на процедурное программирование, обеспечивающую удобство применения структурного стиля программирования;</li>
	<li>систему типов, предохраняющую от бессмысленных операций;</li>
	<li>использование препроцессора для, например, определения макросов и включения файлов с исходным кодом;</li>
	<li>непосредственный доступ к памяти компьютера через использование указателей;</li>
	<li>минимальное число ключевых слов;</li>
	<li>передачу параметров в функцию по значению, а не по ссылке (при этом передача по ссылке выполняется с помощью указателей);</li>
	<li>указатели на функции и статические переменные</li>
	<li>области действия имён;</li>
	<li>записи — определяемые пользователем собирательные типы данных (структуры), которыми можно манипулировать как одним целым;</li>
</ul>
<p>Вот некоторые особенности других языков программирования, которых не имеет Си:</p>
<ul>
	<li>автоматическое управление памятью;</li>
	<li>поддержка объектно-ориентированного программирования (при этом первые версии C++ генерировали код программы на языке Си);</li>
	<li>замыкание;</li>
	<li>вложенные функции (существуют компиляторы языка Си реализующие эту функцию, например компилятор GNU);</li>
	<li>полиморфизм функций и операторов;</li>
	<li>встроенная поддержка многозадачности и сети;</li>
	<li>функции высшего порядка;</li>
	<li>карринг.</li>
</ul>

<p>После появления язык Си был хорошо принят, потому что он позволял быстро создавать компиляторы для новых платформ, а также позволял программистам довольно точно представлять, как выполняются их программы. Благодаря этому программы, написанные на Си, эффективнее написанных на многих других языках. Как правило, лишь оптимизированный вручную код на ассемблере может работать ещё быстрее, потому что он даёт полный контроль над машиной, однако развитие современных компиляторов вместе с усложнением современных процессоров быстро сократило этот разрыв.</p>
<a name="syntax"></a>
<p>Одним из последствий высокой эффективности и переносимости Си стало то, что многие компиляторы, интерпретаторы и библиотеки других языков высокого уровня часто выполнены на языке Си.</p>
<h2>Описание синтаксиса</h2>
<h3>Выражения языка C/C++.</h3>
Операторы, константы и переменные являются составными частями выражений. Выражения в С это любая допустимая комбинация этих частей. Поскольку большинство выражений подчиняется стандартным правилам алгебры, они, как правило, используются в соответствии с данными правилами. Тем не менее, имеются некоторые аспекты выражений, характерных для С.

<h3>Арифметические операции</h3>
<p>Таблица 2.1 Арифметические операции<p>
<table>
	<tr>
		<th>Оператор</th>
		<th>Операция, которая проводится с данными</th>
	</tr>
	<tr>
		<td>+</td>
		<td>Сложение данных</td>
	</tr>
	<tr>
		<td>-</td>
		<td>Вычитание данных</td>
	</tr>
	<tr>
		<td>*</td>
		<td>Умножение данных</td>
	</tr>
	<tr>
		<td>/</td>
		<td>Деление данных</td>
	</tr>
	<tr>
		<td>%</td>
		<td>Деление данных по модулю</td>
	</tr>
</table>

<h3>Оператор присваивания</h3>
<p>Общий вид оператора присваивания следующий:</p>
<p>имя_переменной = выражение;</p>
<p>где выражение может быть как простой одиночной константой, так и сложной комбинацией переменных, операторов и констант. Как в Бейсике и Фортране, в С используется знак равенства для отображения операции присваивания (не так, как в Паскале или Модуле-2, где используется конструкция :=). В левой части оператора присваивания должна стоять переменная, а не функция или константа.</p>
<p>Таблица 2.2 Оператор присваивания</p>
<table>
	<tr>
		<th>Комбинированный оператор</th>
		<th>Операция (что происходит при использовании в коде)</th>
	</tr>
	<tr>
		<td>+=</td>
		<td>Сложение данных с присваиванием</td>
	</tr>
	<tr>
		<td>-=</td>
		<td>Вычитание данных с присваиванием</td>
	</tr>
	<tr>
		<td>*=</td>
		<td>Умножение данных с присваиванием</td>
	</tr>
	<tr>
		<td>/=</td>
		<td>Деление данных с присваиванием</td>
	</tr>
	<tr>
		<td>%=</td>
		<td>Деление данных по модулю с присваиванием</td>
	</tr>
</table>

<h3>Операции сравнения:</h3>
<p>С имеет очень мощный оператор, который можно использовать вместо структуры if-then-else. Оператор ? имеет следующий вид:</p>

<pre class='code'>
выражение1 ? выражение2 : выражение3</pre>

<p>где выражение1, выражение2 и выражениеЗ - это выражения.</p>
<p>Оператор ? работает следующим образом: вычисляется выражение1; если оно истинно, то вычисляется выражение2 и все выражение получает это значение; а если оно ложно, то вычисляется выражение3 и все выражение получает это значение. Например:</p>
<pre class = 'code'>
х = 10;
у =  х > 9 ? 100 : 200;</pre>

<p>В данном примере у получает значение 100. Если бы х было меньше, чем 9, то у получило бы значение 200. Ниже приведен фрагмент программы, выполняющий такие же действия, но с использованием операторов if/else:</p>
<pre class='code'>
х = 10;
if (х > 9) у = 100;
else у = 200;</pre>
<p>Таблица 2.3 Операторы сравнения</p>
<table>
	<tr>
		<td><pre class="code">==</pre></td>
		<td>Равенство (равно)</td>
	</tr>
	<tr>
		<td><pre class="code">!=</pre></td>
		<td>Не равно</td>
	</tr>
	<tr>
		<td><pre class="code">!</pre></td>
		<td>Логическое отрицание</td>
	</tr>
	<tr>
		<td><pre class="code">>=</pre></td>
		<td>Больше или равно</td>
	</tr>
	<tr>
		<td><pre class="code"><=</pre></td>
		<td>Меньше или равно</td>
	</tr>
	<tr>
		<td><pre class="code">></pre></td>
		<td>Больше</td>
	</tr>
	<tr>
		<td><</td>
		<td>Меньше (по возможности желательно воздержаться от применения этого типа)</td>
	</tr>
</table>


<h3>Базовые операторы языка C/C++</h3>
<p>Программы на языке C/C++ обычно состоят из программных блоков или единичных операторов. Программные блоки - это группы операторов, которые заключаются в фигурные скобки { и }. Каждый оператор, если он занимает единственную строку, имеет разграничивающую точку с запятой ;, обозначающую окончание оператора. Каждый оператор имеет собственный синтаксис. Синтаксис оператора - это набор правил, определяющих обязательные и допустимые для использования в данном операторе значения. При несоблюдении правил синтаксиса произойдет ошибка компиляции.</p>
<h3>Операторы комментариев и примечаний</h3>
<p>В С все комментарии начинаются с пары символов /* и заканчиваются парой */. Между слэшем и звездочкой не должно быть пробелов. Компилятор игнорирует любой текст между данными па­рами символов. Например, следующая программа выводит на экран только hello:</p>

<pre class='code'>
#include <stdio.h>
int main(void)
{
printf("hello");
/* printf("there"); */
return 0;
}</pre>

<p>Комментарии могут находиться в любом месте программы, за исключением случая, когда ком­ментарий разбивает на части ключевое слово или идентификатор.</p>
<p>Комментарии не могут быть вложенными, т.е. один комментарий не может содержать другой комментарий.</p>
<p>Комментарии следует использовать, когда необходимо объяснить какую-либо операцию кода. Все функции, за исключением самых очевидных, должны содержать комментарии в начале их объяв­ления, где следует писать, что функция делает, какие параметры она получает и что возвращает.</p>

<h3>Операторы циклов</h3>

<p>В С и других современных языках программирования циклы позволяют выполнять набор инструкций до тех пор, пока не выполнится некоторое условие.</p>

<h4>Цикл for</h4>
<p>Стандартный формат цикла for в С, вероятно, знаком читателю, поскольку его можно найти в той или иной форме во всех языках программирования. Тем не менее, в С цикл for обладает дополнительной гибкостью и мощью.</p>
<p>Стандартный вид цикла for следующий:</p>

<pre class='code'>
for (инициализация; условие; увеличение) оператор;</pre>

<p>Оператор for имеет три главные части:</p>
<ol>
	<li>Инициализация - это место, где обычно находится оператор присваивания, используемый для установки начального значения переменной цикла.</li>
	<li>Условие - это место, где находится выражение, определяющее условие работы цикла.</li>
	<li>Увеличение - это место, где определяется характер изменения переменной цикла на каждой итерации.</li>
</ol>
<p>Эти три важные части должны разделяться точкой с запятой. Цикл for работает до тех пор, пока условие истинно. Когда условие становится ложным, выполнение программы продолжается с оператора, следующего за циклом for.</p>
<h4>Цикл while</h4>
<p>Следующий итерационный оператор, доступный в С, - это while. Его стандартный вид следующий:</p>

<pre class='code'>
while (условие) оператор;</pre>

<p>где оператор - это или пустой, или простой, или составной оператор. Условием может любое выражение, имеющее в качестве истины ненулевое значение. Цикл выполняется, пока условие истинно. Когда условие становится ложным, выполняется строка, следующая за циклом.</p>
<p>Следующий пример показывает процедуру, обрабатывающую ввод с клавиатуры, работающую пока не будет введен символ А:</p>
<pre class='code'>
void wait_for_char(void)
{
char ch;
ch = '\0'; /* инициализация ch */
while(ch!='A') ch = getchar ();
}</pre>

<p>Как и цикл for, цикл while сначала выполняет проверку, то есть тело цикла может вообще не выполняться. Благодаря этому можно не выполнять отдельные проверки перед циклом.</p>

<h4>Цикл do while</h4>
<p>В противоположность циклам for и while, сначала проверяющим условие, цикл do/while проверяет условие в конце. То есть, цикл do/while всегда выполняется, по крайней мере, один раз. Стандартный вид цикла do/while следующий:</p>
<pre class='code'>
do {
последовательность операторов;
}
while (условие);</pre>

<p>Хотя в фигурных скобках нет необходимости при наличии одного оператора, они обычно используются для улучшения читабельности и устранения недоразумений (у читателя, а не у компилятора) по поводу цикла while.</p>
<p>Данный цикл do/while осуществляет чтение чисел с клавиатуры до тех пор, пока одно из них не станет меньше либо равно 100:</p>

<pre class='code'>
do {
scanf ("%d", &num);
} while (num > 100);</pre>

<p>Возможно, наиболее типичным использованием цикла do/while является процедура выбора пунктов меню. Когда набран корректный ответ, она возвращает значение функции. Неправильный ответ приводит к повторному вводу.</p>

<h3>Определение функции</h3>

<p>Функции - это базовые блоки С, в которых выполняются все операции. Стандартный вид функций следующий:</p>

<pre class='code'>
спецификатор_типа имя_функции (список параметров)
{
тело функции
}</pre>
<p>Спецификатор_типа определяет тип возвращаемого функцией значения с помощью оператора return. Это может быть любой допустимый тип. Если тип не указан, предполагается, что функция возвращает целочисленные значения. Список параметров - это разделенный запятыми список переменных, получающий значение аргументов при вызове функции. Функция может быть без параметров и в таком случае список параметров содержит ключевое слово void.</p>
<p>Оператор return имеет два назначения. Во-первых, немедленный выход из функции. То есть он осуществляет выход в вызывавший функцию код. Во-вторых, может использоваться для возврата значения. Здесь рассмотрены оба назначения.</p>

			</div>
		</div>
		<footer>Design studio 2017 ©</footer>
		<script type="text/javascript">
			var links = document.getElementsByClassName("header_link");
			var i;
			for (i = 0; i < links.length; i++)
			{
				links[i].i = i;
				links[i].onmouseenter = function(event)
				{
					var j = 0;
					for (j = 0; j < links.length; j++)
					{
						links[j].style.color = "#eee";
					}
					this.style.color = "#55aa55";

					var submenus = document.getElementsByClassName("header_submenu");
					var k;
					for (k = 0; k < submenus.length; k++)
					{
						submenus[k].style.display = "none";
					}

					switch (this.i)
					{
						case 0:
							document.getElementById("java_submenu").style.display = "block";
							break;
						case 1:
							document.getElementById("c_submenu").style.display = "block";
							break;
						case 2:
							document.getElementById("pascalabc_submenu").style.display = "block";
							break;
						case 3:
							document.getElementById("fs_submenu").style.display = "block";
							break;
					}
				};
			}

			document.getElementById("header").onmouseleave = function(event)
			{
				var submenus = document.getElementsByClassName("header_submenu");
				var k;
				for (k = 0; k < submenus.length; k++)
				{
					submenus[k].style.display = "none";
				}
				var links = document.getElementsByClassName("header_link");
				var j = 0;
				for (j = 0; j < links.length; j++)
				{
					links[j].style.color = "#eee";
				}
			};
		</script>
	</body>
</html>
